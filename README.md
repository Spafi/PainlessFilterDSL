# Painless Filter DSL

Painless Filter DSL is a utility service designed to ease the task of creating and handling dynamic filtering, sorting and pagination for Spring Data JPA with the use of QueryDSL. This library abstracts the complexity of creating predicates for filtering, sorting and pagination operations for any entity class.

The goal of this service is to provide an easy-to-use, maintainable, and extendable way of implementing complex queries in your Spring Data applications.

## Usage

### 1. Filtering

Filtering in Painless Filter DSL is based on the `FilterRequest` objects. These are simple data objects that specify the column to be filtered, the type of the field, the operation to be performed, and the value(s) to filter.

Filtering operations such as `EqualOperation`, `NotEqualOperation`, `ContainsOperation`, `StartsWithOperation`, `EndsWithOperation`, `DateBeforeOperation`, `DateAfterOperation`, `InListOperation`, `NotInListOperation` are implemented in this library.

Here is an example of how to use them:

```kotlin
val filterRequest = FilterRequest(
    columnPath = "column_name",
    fieldType = FieldType.STRING,
    operation = EqualOperation(),
    value = "value_to_filter"
)
```

### 2. Sorting

Sorting is done by using `SortRequest` objects. These objects specify the column to be sorted and the direction of sorting. The direction can be ascending (`AscOperation`) or descending (`DescOperation`).

Here is an example of creating a `SortRequest`:

```kotlin
val sortRequest = SortRequest(
    columnPath = "column_name",
    direction = AscOperation()
)
```

### 3. Pagination

Pagination is handled via the `buildPageRequest` function in `FilteringService` which takes sorting order, page size, and page number as arguments and returns a `PageRequest` object:

```kotlin
val pageRequestOutcome = FilteringService.buildPageRequest(
    sortOrder = listOf(sortRequest),
    pageSize = 10,
    pageNumber = 0
)
```

### 4. Combining Filters, Sorting and Pagination

The `validateAndAddOptionalFilters` function in `FilteringService` can be used to add optional filters to an `IEntityFilterAndSortPageRequest` and return a `FilteredSortedPageRequest`.

```kotlin
val outcome = FilteringService.validateAndAddOptionalFilters(
    entityFilterAndSortPageRequest = entityFilterAndSortPageRequest,
    additionalFilters = filterRequest1, filterRequest2
)
```

This will return an `Outcome<FilteredSortedPageRequest>` that can then be used to perform a filtered, sorted, and paginated query.

Please note that before using Painless Filter DSL, you should set up QueryDSL in your project, and the entities should have corresponding Q-classes generated by QueryDSL.


# Example usage of Painless Filter DSL in a Spring Boot application

An example project is included that demonstrates how to use the Painless Filter DSL with a Spring Boot REST controller for a product entity. The product data can be sorted, filtered, and paginated based on the parameters provided in the request body. 

## Pre-requisites

Make sure you have:

1. Spring Boot setup for your application.
2. Set up QueryDSL in your project, and entities should have corresponding Q-classes generated by QueryDSL.
4. Run the basic SQL File provided, or insert dummy data in the database.


## Sending Requests

After your server is running, you can send POST requests to the endpoint `/api/example/filteredData`.

Here is an example of a request body:

```json
{
    "filters": [
        {
            "columnName": "dtoName",
            "fieldType": "STRING",
            "value": "s",
            "operation": "STARTS_WITH"
        },
         {
            "columnName": "status",
            "fieldType": "ENUM",
            "value": "INACTIVE",
            "operation": "EQUAL"
        }
    ],
    "sort": [
        {
            "columnName": "dtoName",
            "direction": "ASC"
        }
    ],
    "page": 0,
    "size": 5
}
```

In this request, the server will return a paginated list of products that have their name starting with the letter "s", and with a status of "INACTIVE", sorted in ascending order by the name. The response will contain up to 5 products, and it will represent the first page of the possible results.
